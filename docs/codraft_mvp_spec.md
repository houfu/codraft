# Codraft — Project Specification (MVP)

**Version:** 0.1 (MVP)
**Date:** 2026-02-15
**Platform:** Claude Cowork

---

## 1. Overview

Codraft is a document assembly tool built as a set of Claude Cowork skills. It replaces traditional document automation platforms (docassemble, HotDocs) by using Claude to interview the user, collect variable values, and produce completed documents from templates.

The user maintains a folder of docx templates containing `{{ variable }}` placeholders. When the user asks to prepare a document, Codraft identifies the right template, walks the user through every field, and renders the final document.

### 1.1 MVP Scope

The MVP supports **simple variable substitution only**:

- Templates contain `{{ variable_name }}` placeholders
- No conditional logic (`{% if %}`)
- No loops (`{% for %}`)
- No computed fields or expressions
- No nested templates or includes
- Flat template directory (no subdirectories)

### 1.2 What MVP Delivers

- Template discovery and selection (automatic or interactive)
- Variable extraction from docx templates
- Conversational interview to collect all variable values
- Basic type inference and validation
- Rendered docx output with a sensible filename

---

## 2. Architecture

Codraft consists of three skills:

| Skill | Purpose | Depends On |
|---|---|---|
| **Renderer** | Fills template with collected values, produces final docx | Template file, completed variables |
| **Analyzer** | Parses template, extracts variables, infers types | Template file |
| **Orchestrator** | Drives the full session: discovery → analysis → interview → render | Analyzer, Renderer |

The Orchestrator is the entry point. It calls the Analyzer and Renderer as sub-steps.

In the MVP, all three skills can be implemented as a single SKILL.md with distinct phases, or as three separate skill files. The recommendation is **one SKILL.md (Orchestrator)** that contains the Analyzer and Renderer logic inline, since the MVP is simple enough that separation adds overhead without benefit. They can be split out in v2 when complexity warrants it.

---

## 3. Directory Structure

```
codraft/                          # Cowork project folder
├── SKILL.md                      # Orchestrator skill (main entry point)
├── templates/                    # Template library
│   ├── tenancy_agreement/        # Each template gets its own directory
│   │   ├── tenancy_agreement.docx
│   │   └── manifest.json         # Generated by Analyzer, cached
│   ├── employment_contract/
│   │   ├── employment_contract.docx
│   │   └── manifest.json
│   └── nda/
│       ├── nda.docx
│       └── manifest.json
└── output/                       # Rendered documents land here
```

### 3.1 Templates Directory

- Each template lives in its own subdirectory under `templates/`
- The directory name is the template's identifier (used for matching user intent)
- Each directory contains:
  - The `.docx` template file (with `{{ variable_name }}` placeholders)
  - `manifest.json` — generated by the Analyzer on first run, then cached
  - (Future: `config.yaml` for developer overrides, question customisations, etc.)
- Templates are pre-loaded by the developer/user — Codraft does not create templates
- The Analyzer only re-generates the manifest if the docx file is newer than the existing manifest, or if no manifest exists

### 3.2 Output Directory

- Rendered documents are saved here
- Naming convention: `{template_name}_{key_variable}_{date}.docx`
- Example: `tenancy_agreement_alice_tan_2026-02-15.docx`

---

## 4. Skill Specifications

### 4.1 Analyzer Phase

**Input:** A template directory path (e.g., `templates/tenancy_agreement/`).

**Process:**

1. Locate the `.docx` file in the directory
2. Check if `manifest.json` already exists and is up to date (docx file hasn't been modified since manifest was generated). If manifest is current, skip to output.
3. Read the docx file using `python-docx` or `docxtpl`
4. Scan all text content (paragraphs, tables, headers, footers) for `{{ variable_name }}` patterns
5. Extract unique variable names using regex: `\{\{\s*(\w+)\s*\}\}`
6. For each variable, infer:
   - **label**: Human-readable version of the variable name (e.g., `landlord_name` → "Landlord Name")
   - **type**: Based on naming conventions:
     - `*_name`, `*_address` → `text`
     - `*_date` → `date`
     - `*_email` → `email`
     - `*_amount`, `*_price`, `*_fee` → `number`
     - `*_phone`, `*_tel`, `*_mobile` → `phone`
     - Default → `text`
7. Deduplicate (same variable appearing multiple times counts once)
8. Preserve the order variables appear in the document (first occurrence)
9. Save `manifest.json` to the template directory
10. Output the variable manifest

**Output format (saved as `manifest.json` in the template directory):**

```json
{
  "template": "tenancy_agreement.docx",
  "template_path": "templates/tenancy_agreement/tenancy_agreement.docx",
  "analyzed_at": "2026-02-15T10:30:00Z",
  "variable_count": 8,
  "variables": [
    {
      "name": "landlord_name",
      "label": "Landlord Name",
      "type": "text"
    },
    {
      "name": "commencement_date",
      "label": "Commencement Date",
      "type": "date"
    },
    {
      "name": "rental_amount",
      "label": "Rental Amount",
      "type": "number"
    }
  ]
}
```

**Edge cases to handle:**

- Variables inside tables
- Variables in headers/footers
- Malformed placeholders (e.g., `{{landlord_name}` missing closing braces) — skip and warn
- Empty template (no variables found) — inform user
- Multiple docx files in one directory — use the first one found and warn

### 4.2 Orchestrator Phase

The orchestrator drives the entire session from start to finish.

**Step 1 — Template Discovery**

1. List all subdirectories in `templates/`
2. If the user's query clearly indicates a template (e.g., "prepare an NDA"), match it to a directory name and proceed directly
3. If ambiguous or no match, present the list and ask the user to choose
4. Matching should be fuzzy and reasonable — "tenancy" matches `tenancy_agreement/`, "employment" matches `employment_contract/`

**Step 2 — Variable Extraction**

1. Run the Analyzer on the selected template directory
2. Load the manifest (freshly generated or cached)

**Step 3 — Interview Plan**

Before asking any questions, the orchestrator creates an **interview plan**. This is a brief reasoning step where Claude examines the full variable manifest and the template name/context, then decides:

1. **Grouping**: Which variables belong together and should be asked in the same turn? Group by logical affinity, not just document order. Examples:
   - All landlord details together (name, address, email, phone)
   - All tenant details together
   - All financial terms together (rental amount, deposit, payment date)
   - All dates together if they're related (commencement date, expiry date)

2. **Ordering**: What sequence should the groups be asked in? Follow natural conversational flow:
   - Parties first (who is involved?)
   - Subject matter next (what is this about?)
   - Terms and conditions (financial details, dates, obligations)
   - Administrative details last (governing law, notice addresses)

3. **Question phrasing**: For each group, draft the questions. Use natural language, not just "What is the [label]?":
   - Consider the document type for context (a tenancy agreement vs an NDA will frame questions differently)
   - Add format guidance where relevant (dates, currency, etc.)

The plan is internal to Claude — it doesn't need to be shown to the user — but it should be generated explicitly so the interview feels coherent and well-structured rather than mechanical.

**Example interview plan (internal):**

```
Template: Tenancy Agreement
Groups:
  1. Landlord details — landlord_name, landlord_address, landlord_email
     → "Let's start with the landlord's details. What is the landlord's
        full name, address, and email?"
  2. Tenant details — tenant_name, tenant_address, tenant_email
     → "Now the tenant's details..."
  3. Property — property_address, property_type
     → "What is the address of the rental property, and what type of
        property is it (e.g., HDB, condo, landed)?"
  4. Financial terms — rental_amount, deposit_amount, payment_day
     → "What is the monthly rent, security deposit, and which day of
        the month is rent due?"
  5. Dates — commencement_date, expiry_date
     → "When does the tenancy start and end?"
  6. Other — governing_law
     → "What is the governing law for this agreement?"
```

**Step 4 — Interview Loop**

1. Follow the interview plan, presenting one group at a time
2. Collect the user's answers
3. Parse answers to match them to the correct variables within the group (Claude should handle this naturally — if asked for "name, address, and email" and the user provides all three, map them correctly)
4. Validate based on type:
   - `date`: Check it looks like a date
   - `number`: Check it's numeric
   - `email`: Check basic email format
   - `text`: Accept anything non-empty
5. If validation fails for a specific variable, ask again with guidance
6. If the user provides a partial answer (e.g., gives name but not address), acknowledge what was received and ask for the rest
7. Store all answers
8. Move to the next group
9. Repeat until all groups are complete

**Step 5 — Confirmation**

1. Present a summary of all collected values, organised by group
2. Ask the user to confirm or correct any values
3. If corrections are needed, update the values and re-confirm

**Step 6 — Render**

1. Once confirmed, trigger the Renderer
2. Present the completed document to the user

**Step 7 — Post-render**

1. Offer: "Would you like to prepare another document?"

### 4.3 Renderer Phase

**Input:** Template file path + dictionary of variable name → value pairs.

**Process:**

1. Load the template using `docxtpl`
2. Pass the variable dictionary to `docxtpl`'s `render()` method
3. Save the rendered document to `output/` with a descriptive filename

**Output:** Path to the completed docx file.

**Technical choice — docxtpl:**

Use `docxtpl` (not raw `python-docx` with string replacement) because:
- It natively supports `{{ }}` Jinja2 syntax in docx
- It preserves formatting (bold, italic, fonts) around variables
- It will seamlessly support `{% if %}` and `{% for %}` when we add logic in v2
- Install via: `uv pip install docxtpl`

**Edge cases:**

- Variable in the manifest but no value provided → raise error, don't render with blanks
- Value contains special characters → docxtpl handles escaping
- Very long values → let them flow; docx will wrap naturally

---

## 5. Technical Decisions

| Decision | Choice | Rationale |
|---|---|---|
| Template engine | `docxtpl` | Native `{{ }}` support, preserves formatting, supports Jinja2 for v2 |
| Python environment | `uv` | User preference |
| Manifest storage | JSON in template directory | Co-located with its template, cacheable, human-readable |
| Template directory | Per-template subdirectories | Keeps template + manifest + future config together as a unit |
| Question generation | Interview plan in orchestrator | Groups and orders questions for natural conversational flow |
| Output naming | `{template}_{key_var}_{date}.docx` | Descriptive, sortable, avoids overwrites |

---

## 6. Build Order

### Phase 1 — Renderer

Build and test the rendering pipeline in isolation.

**Test approach:**
1. Create a sample template with 3-4 variables
2. Hardcode a variable dictionary
3. Render and verify the output docx is correct
4. Verify formatting is preserved around filled variables

**Done when:** Given a template and a complete dictionary, a correctly filled docx is produced.

### Phase 2 — Analyzer

Build and test variable extraction in isolation.

**Test approach:**
1. Run against the sample template directory from Phase 1
2. Verify all variables are found and deduplicated
3. Verify type inference works for common suffixes
4. Test edge cases: variables in tables, headers, footers
5. Verify `manifest.json` is saved in the template directory
6. Verify re-running skips analysis if manifest is current

**Done when:** Given a template directory, a correct and complete `manifest.json` is produced and cached.

### Phase 3 — Orchestrator

Wire everything together into the interview flow.

**Test approach:**
1. Place sample template directories in `templates/`
2. Run a full session: discovery → analysis → plan → interview → render
3. Verify template matching works from natural language
4. Verify the interview plan groups variables sensibly
5. Verify the interview collects all values correctly
6. Verify the confirmation summary is accurate
7. Verify the final document is correct

**Done when:** A user can say "prepare a tenancy agreement", answer grouped questions, and receive a completed docx.

---

## 7. Example Session (MVP)

```
User: I need to prepare an NDA

Claude: [scans templates/ directory, finds match]
        I'll use the NDA template. I've found 6 fields to complete,
        and I'll walk you through them in 3 steps.

        First, the disclosing party. What is the disclosing party's
        full name and address?

User: Acme Pte Ltd, 123 Robinson Road #04-01 Singapore 068913

Claude: Now the receiving party. What is the receiving party's full
        name and address?

User: Jane Smith, 45 Orchard Boulevard #12-05 Singapore 248651

Claude: Finally, the agreement terms. What is the effective date
        (DD/MM/YYYY), how long is the confidentiality period, and
        what is the governing law?

User: 1 March 2026, 2 years, Singapore law

Claude: Here's a summary of all the details:

        Disclosing Party:
        - Name: Acme Pte Ltd
        - Address: 123 Robinson Road #04-01 Singapore 068913

        Receiving Party:
        - Name: Jane Smith
        - Address: 45 Orchard Boulevard #12-05 Singapore 248651

        Agreement Terms:
        - Effective Date: 01/03/2026
        - Confidentiality Period: 2 years
        - Governing Law: Singapore law

        Shall I produce the document?

User: Yes

Claude: Done! Your NDA has been saved as:
        output/nda_acme_pte_ltd_2026-02-15.docx
```

---

## 8. Future Versions (Out of MVP Scope)

Documented here so MVP design doesn't accidentally block them:

- **v2 — Conditional logic**: Support `{% if %}` / `{% else %}` in templates. Requires dependency graph in Analyzer and conditional skipping in Orchestrator.
- **v2 — Loops**: Support `{% for item in items %}` for repeating sections. Requires the Orchestrator to handle list-type variables ("Add another party?").
- **v2 — Separate Question Generator skill**: With logic and context-aware questions, this becomes complex enough to warrant its own skill.
- **v2 — Developer configuration file**: A YAML file alongside each template providing question overrides, validation rules, grouping hints, and contextual descriptions.
- **v3 — Multi-template workflows**: Chaining templates (e.g., "prepare the NDA and the employment contract for the same person" — share variables across documents).
- **v3 — Template categories**: Organise template directories into category groups (e.g., `templates/hr/`, `templates/property/`).
- **v3 — PDF output option**.
- **v3 — Session resume**: Pick up an interrupted interview from the state file.
